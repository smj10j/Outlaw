//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHBezier.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHPathNode.h"
#import "LHSettings.h"
#import "LHSprite.h"
#import "LHLayer.h"
#import <Availability.h>
#import "LHCustomClasses.h"
#import "LHDictionaryExt.h"

#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
#import <OpenGLES/EAGL.h>
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
#import <OpenGL/OpenGL.h>
#endif


typedef struct _ccV3F_C4B_T2F_Triangle
{
	//! top left
	ccV3F_C4B_T2F	tl;
    //! top right
	ccV3F_C4B_T2F	tr;
	//! bottom
	ccV3F_C4B_T2F	bc;
    
} lhV3F_C4B_T2F_Triangle;


typedef struct lhV3F_C4B
{
    ccVertex3F point;
    ccColor4B color;    
} lhV3F_C4B;



typedef struct lhV3F_Line
{
	lhV3F_C4B	A;
	lhV3F_C4B	B;   
} lhV3F_Line;


@interface LHBezierBlendingInfo : NSObject
{
    CCTexture2D* texture;
    GLenum blendSource;
    GLenum blendDestination;
    bool tile;
}

+(id) bezierBlendingInfoWithTexture:(CCTexture2D*)tex
                        blendSource:(GLenum)source
                   blendDestination:(GLenum)destination
                               tile:(bool)shouldTile;

-(id) initBezierBlendingInfoWithTexture:(CCTexture2D*)tex
                            blendSource:(GLenum)source
                       blendDestination:(GLenum)destination
                                   tile:(bool)shouldTile;

-(CCTexture2D*) texture;
-(GLenum) blendSource;
-(GLenum) blendDestination;
-(bool) tile;
@end
//------------------------------------------------------------------------------
@implementation LHBezierBlendingInfo
-(void) dealloc{
#ifndef LH_ARC_ENABLED
	[super dealloc];
#endif
}
+(id) bezierBlendingInfoWithTexture:(CCTexture2D*)tex
                        blendSource:(GLenum)source
                   blendDestination:(GLenum)destination
                               tile:(bool)shouldTile;
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initBezierBlendingInfoWithTexture:tex
                                                blendSource:source
                                           blendDestination:destination
                                                       tile:shouldTile] autorelease];
#else
    return [[self alloc] initBezierBlendingInfoWithTexture:tex
                                                blendSource:source
                                           blendDestination:destination
                                                       tile:shouldTile];
#endif
}
-(id) initBezierBlendingInfoWithTexture:(CCTexture2D*)tex
                            blendSource:(GLenum)source
                       blendDestination:(GLenum)destination
                                   tile:(bool)shouldTile{
	if( (self=[super init])) {
        texture = tex;
        blendSource = source;
        blendDestination = destination;
        tile = shouldTile;
	}
	return self;
}

-(CCTexture2D*) texture{return texture;}
-(GLenum) blendSource{return blendSource;}
-(GLenum) blendDestination{return blendDestination;}
-(bool) tile{return tile;}

@end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHBezier (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHBezier
@synthesize isClosed;
@synthesize isTile;
@synthesize isVisible;
@synthesize isLine;
@synthesize swallowTouches;
////////////////////////////////////////////////////////////////////////////////
-(void) dealloc{		
    
//    NSLog(@"LHBezier Dealloc %@", uniqueName);
    
    [LevelHelperLoader removeTouchDispatcherFromObject:self];

    [self removeBodyFromWorld];
    
#ifndef LH_ARC_ENABLED    
    
    if(userCustomInfo){
        [userCustomInfo release];
        userCustomInfo = nil;
    }
    
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchBeginObserver)
        [touchMovedObserver release];
    if(touchBeginObserver)
        [touchEndedObserver release];    

    if(texture)
        [texture release];
    [blendingTextures release];
	[uniqueName release];	
	[pathPoints release];
	[linesHolder release];
	[trianglesHolder release];

	[super dealloc];
#endif
}

-(void)removeBodyFromWorld{
#ifdef LH_USE_BOX2D
	if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
			_world->DestroyBody(body);
			body = NULL;
		}
	}
#endif
}

-(LevelHelperLoader*)parentLoader{
    
    CCNode* layerParent = self.parent;
    
    while (layerParent && ![layerParent isKindOfClass:[LHLayer class]])
    {
        layerParent = layerParent.parent;
    }
    
    if(layerParent && [layerParent isKindOfClass:[LHLayer class]]) {
        return [(LHLayer*)layerParent parentLoader];
    }
    return nil;
}


-(void)removeSelf{
    
#ifdef LH_USE_BOX2D
    if(body){
        if(body->GetWorld()->IsLocked()){            
            [[LHSettings sharedInstance] markBezierForRemoval:self];
            return;
        }
    }
#endif
    
    [self removeFromParentAndCleanup:YES];
}

-(void) onExit{
//    NSLog(@"LHBEZIER %@ onExit", uniqueName);
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
}

////////////////////////////////////////////////////////////////////////////////
+(CGPoint) pointOnCurve:(CGPoint) p1 p2:(CGPoint)p2 p3:(CGPoint)p3 p4:(CGPoint)p4 t:(float)t
{
	float var1, var2, var3;
    CGPoint vPoint = {0.0f, 0.0f};
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);				
}
////////////////////////////////////////////////////////////////////////////////
-(void) initTileVerticesFromDictionary:(NSDictionary*)dictionary tileVertices:(NSArray*)fixtures
{
	trianglesHolder = [[NSMutableArray alloc] init];
    
//#if COCOS2D_VERSION >= 0x00020000
//    float scale = 1;
//#else
//    float scale = CC_CONTENT_SCALE_FACTOR();
//#endif
//
//    NSLog(@"SCALE IS %f", scale);
    
    
	for(NSArray* fix in fixtures)
	{
		NSMutableArray* triangle = [[NSMutableArray alloc] init];
		for(NSString* pt in fix)
		{
			CGPoint point = LHPointFromString(pt);
			
            point = [[LHSettings sharedInstance] transformedPointToCocos2d:point];

			[triangle addObject:LHValueWithCGPoint(point)];
		}
		
		[trianglesHolder addObject:triangle];
#ifndef LH_ARC_ENABLED
		[triangle release];
#endif
	}	
	
	
	linesHolder = [[NSMutableArray alloc] init];
	if(isVisible)
	{
		NSArray* curvesInShape = [dictionary objectForKey:@"Curves"];
		
		int MAX_STEPS = 25;
		
		for(NSDictionary* curvDict in curvesInShape)
		{
			CGPoint endCtrlPt   = [curvDict pointForKey:@"EndControlPoint"];
			CGPoint startCtrlPt = [curvDict pointForKey:@"StartControlPoint"];
			CGPoint endPt       = [curvDict pointForKey:@"EndPoint"];
			CGPoint startPt     = [curvDict pointForKey:@"StartPoint"];
			            
			if(!isLine)
			{
				CGPoint prevPoint;
				bool firstPt = true;
				
				for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
				{
					CGPoint vPoint = [LHBezier pointOnCurve:startPt
                                                         p2:startCtrlPt
                                                         p3:endCtrlPt
                                                         p4:endPt
                                                          t:t];
					
					if(!firstPt)
					{
                        CGPoint pt1 = [[LHSettings sharedInstance] transformedPointToCocos2d:prevPoint];
                        CGPoint pt2 = [[LHSettings sharedInstance] transformedPointToCocos2d:vPoint];
                        
						[linesHolder addObject:LHValueWithCGPoint(pt1)];
						[linesHolder addObject:LHValueWithCGPoint(pt2)];
					}
					prevPoint = vPoint;
					firstPt = false;					
				}
			}
			else
			{
				
                CGPoint pos1 = [[LHSettings sharedInstance] transformedPointToCocos2d:startPt];
                CGPoint pos2 = [[LHSettings sharedInstance] transformedPointToCocos2d:endPt];
                
				[linesHolder addObject:LHValueWithCGPoint(pos1)];
				[linesHolder addObject:LHValueWithCGPoint(pos2)];
				
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
-(void) initPathPointsFromDictionary:(NSDictionary*)bezierDict
{
	pathPoints = [[NSMutableArray alloc] init];
	
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];    
    int MAX_STEPS = 25;    
//	CGPoint conv = [[LHSettings sharedInstance] convertRatio];
	int i = 0;
    
    
//    float scale = 1;
//    if([[LHSettings sharedInstance] isIphone5])
//        scale = [[CCDirector sharedDirector] contentScaleFactor];

    
//    CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
//    CGPoint user_offset = [[LHSettings sharedInstance] userOffset];
    
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = [curvDict pointForKey:@"EndControlPoint"];
        CGPoint startCtrlPt = [curvDict pointForKey:@"StartControlPoint"];
        CGPoint endPt       = [curvDict pointForKey:@"EndPoint"];
        CGPoint startPt     = [curvDict pointForKey:@"StartPoint"];
		
		
		if(!isLine)
        {
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [LHBezier pointOnCurve:startPt
														 p2:startCtrlPt
														 p3:endCtrlPt
														 p4:endPt
														  t:t];
                
                vPoint = [[LHSettings sharedInstance] transformedPointToCocos2d:vPoint];
//                
//				vPoint = CGPointMake(vPoint.x*conv.x, 
//                                     winSize.height - vPoint.y*conv.y);
//
//                vPoint.x += pos_offset.x/scale;
//                vPoint.y -= pos_offset.y/scale;
//                
//                vPoint.x += user_offset.x/scale;
//                vPoint.y -= user_offset.y/scale;
                
                [pathPoints addObject:LHValueWithCGPoint(vPoint)];
            }
			
			[pathPoints removeLastObject];
        }
        else
        {
            CGPoint sPoint = [[LHSettings sharedInstance] transformedPointToCocos2d:startPt];
            
//            CGPoint sPoint = CGPointMake(startPt.x*conv.x, 
//                                 winSize.height - startPt.y*conv.y);
//            
//            sPoint.x += pos_offset.x/scale;
//            sPoint.y -= pos_offset.y/scale;
//            
//            sPoint.x += user_offset.x/scale;
//            sPoint.y -= user_offset.y/scale;
//            
            
            [pathPoints addObject:LHValueWithCGPoint(sPoint)];            
            
            if(i == (int)[curvesInShape count]-1)
            {
                CGPoint ePoint = [[LHSettings sharedInstance] transformedPointToCocos2d:endPt];
                
//                CGPoint ePoint = CGPointMake(endPt.x*conv.x, 
//                                             winSize.height - endPt.y*conv.y);
//                
//                ePoint.x += pos_offset.x/scale;
//                ePoint.y -= pos_offset.y/scale;
//                
//                ePoint.x += user_offset.x/scale;
//                ePoint.y -= user_offset.y/scale;
                
                [pathPoints addObject:LHValueWithCGPoint(ePoint)]; 
            }
            ++i;            
        }
	}	
	
}
////////////////////////////////////////////////////////////////////////////////
#ifdef LH_USE_BOX2D
-(void) createBodyFromDictionary:(NSDictionary*)dictionary physicWorld:(b2World*)world
{
        
//	if(isPath)
//		return;
//	
//	if([pathPoints count] < 2)
//		return;
	
	b2BodyDef bodyDef;	
	
	int bodyType = [dictionary intForKey:@"Type"];
	if(bodyType > 2)
        return;
              
	bodyDef.type = (b2BodyType)bodyType;
    
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = 0.0f;
	
#ifndef LH_ARC_ENABLED
	bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
	
	body = world->CreateBody(&bodyDef);
	
	float ptm = [[LHSettings sharedInstance] lhPtmRatio];

    for(NSArray* fix in trianglesHolder)
    {
        int size = (int)[fix count];
        b2Vec2 *verts = new b2Vec2[size];
        int i = 0;
        for(int j = (int)[fix count]-1; j >=0; --j)
        {
            NSValue* val = [fix objectAtIndex:(NSUInteger)j];
                        
            CGPoint pt = LHPointFromValue(val);
            
            verts[i].x = pt.x/ptm;
            verts[i].y = pt.y/ptm;            
            ++i;
        }

        b2PolygonShape shape;
        shape.Set(verts, size);		
        
        b2FixtureDef fixture;
        
        
        fixture.density = [dictionary floatForKey:@"Density"];
		fixture.friction = [dictionary floatForKey:@"Friction"];
		fixture.restitution = [dictionary floatForKey:@"Restitution"];
		
		fixture.filter.categoryBits = (uint16)[dictionary intForKey:@"Category"];
		fixture.filter.maskBits = (uint16)[dictionary intForKey:@"Mask"];
		fixture.filter.groupIndex = (int16)[dictionary intForKey:@"Group"];
		
		fixture.isSensor = [dictionary boolForKey:@"IsSensor"];
        
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete[] verts;
    }		
    
    //we test for the version of box2d here 
#ifdef B2_CHAIN_SHAPE_H    
    if([pathPoints count] > 0)
    {
    
        b2Vec2 * verts = new b2Vec2 [(int)[pathPoints count]];

        int i = 0;
        for(NSValue* val in pathPoints)
        {
            CGPoint pt = LHPointFromValue(val);
            verts [i]. x = pt.x / ptm;
            verts [i]. y = pt.y / ptm;
            ++i;
        }

        b2ChainShape shape;
        shape.CreateChain (verts, (int)[pathPoints count]);
        
        b2FixtureDef fixture;
    
    
        fixture.density = [dictionary floatForKey:@"Density"];
        fixture.friction = [dictionary floatForKey:@"Friction"];
        fixture.restitution = [dictionary floatForKey:@"Restitution"];
    
        fixture.filter.categoryBits = (uint16)[dictionary intForKey:@"Category"];
        fixture.filter.maskBits = (uint16)[dictionary intForKey:@"Mask"];
        fixture.filter.groupIndex = (int16)[dictionary intForKey:@"Group"];
    
        fixture.isSensor = [dictionary boolForKey:@"IsSensor"];

        fixture.shape = &shape;
        body-> CreateFixture (& fixture);
        delete [] verts;
    }   
    
#else //old box2d library
    
    if([pathPoints count] > 0)
    {
        float density = [dictionary floatForKey:@"Density"];
        float friction = [dictionary floatForKey:@"Friction"];
        float restitution = [dictionary floatForKey:@"Restitution"];
        
        int categoryBits= [dictionary intForKey:@"Category"];
        int maskBits = [dictionary intForKey:@"Mask"];
        int group = [dictionary intForKey:@"Group"];
        
        int isSensor = [dictionary boolForKey:@"IsSensor"];

        CGPoint firstPt;
        int j = 0; 
        for(int i = 0; i < [pathPoints count]; ++i)
        {
            if(j < [pathPoints count])
            {
            NSValue* val1 = [pathPoints objectAtIndex:j + 0];
            CGPoint pt1 = LHPointFromValue(val1);

            if(j == 0)
                firstPt = pt1;

            CGPoint pt2 = firstPt;

            if(j+1 < [pathPoints count])
            {
                NSValue* val2 = [pathPoints objectAtIndex:j+1];
                pt2 = LHPointFromValue(val2);
            }
            
            j+=2;
            
            b2Vec2 *verts = new b2Vec2[2];
            b2PolygonShape shape;
            
            verts [0]. x = pt1.x / ptm;
            verts [0]. y = pt1.y / ptm;
            
            verts [1]. x = pt2.x / ptm;
            verts [1]. y = pt2.y / ptm;
            
            shape.Set(verts, 2);		
            b2FixtureDef fixture;
            
            fixture.density = density;
            fixture.friction = friction;
            fixture.restitution = restitution;
            
            fixture.filter.categoryBits = categoryBits;
            fixture.filter.maskBits = maskBits;
            fixture.filter.groupIndex = group;
            
            fixture.isSensor = isSensor;

            fixture.shape = &shape;
            body->CreateFixture(&fixture);
            
            delete [] verts;
            }
        }
    }  
    
#endif
}
#endif

-(void) loadUserCustomInfoFromDictionary:(NSDictionary*)dictionary{
    userCustomInfo = nil;
    if(!dictionary)return;
    
    NSString* className = [dictionary stringForKey:@"ClassName"];
    Class customClass = NSClassFromString(className);
    
    if(!customClass) return;
    
    userCustomInfo = [customClass performSelector:@selector(customClassInstance)];
#ifndef LH_ARC_ENABLED
    [userCustomInfo retain];
#endif
    [userCustomInfo performSelector:@selector(setPropertiesFromDictionary:) withObject:[dictionary objectForKey:@"ClassRepresentation"]];
}
-(NSString*)userInfoClassName{
    if(userCustomInfo)
        return NSStringFromClass([userCustomInfo class]);
    return @"No Class";
}
//------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
-(id) initWithDictionary:(NSDictionary*)dictionary 
{
	self = [super init];
	if (self != nil)
	{
        uniqueName = [[NSString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];		
        blendingTextures = [[NSMutableArray alloc] init];

        NSDictionary* textureDict = [dictionary objectForKey:@"TextureProperties"];

        
		isClosed	= [textureDict boolForKey:@"IsClosed"];
		isTile		= [textureDict boolForKey:@"IsTile"];
		isVisible	= [textureDict boolForKey:@"IsDrawable"];
		isLine		= [textureDict boolForKey:@"IsSimpleLine"];
		isPath		= [textureDict boolForKey:@"IsPath"];
        opacity     = [textureDict floatForKey:@"Opacity"];
		
        if([textureDict objectForKey:@"DrawBorder"])
            drawBorder  = [textureDict boolForKey:@"DrawBorder"];
        else
            drawBorder = true;
        
		[self setTag:[textureDict intForKey:@"Tag"]];
		[self setVertexZ:[textureDict intForKey:@"ZOrder"]];
#if COCOS2D_VERSION >= 0x00020000
		[self setZOrder:[textureDict intForKey:@"ZOrder"]];
#else
        zOrder_ = [textureDict intForKey:@"ZOrder"]; //this property is read only on cocos2d 1.0
#endif
        
        
		NSString* img = [textureDict stringForKey:@"ImageFile"];
                
		imageSize = CGSizeZero;
        texture = nil;
        
#if COCOS2D_VERSION >= 0x00020000
        self.shaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_PositionColor];       
        mShaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_Position_uColor];
        mColorLocation = glGetUniformLocation( mShaderProgram->program_, "u_color");
#endif
        
		if(![img isEqualToString:@""] && ![img isEqualToString:@"No Image"])
		{
            
#if COCOS2D_VERSION >= 0x00020000
            NSString* path = [[CCFileUtils sharedFileUtils] fullPathFromRelativePath:img];
#else
            NSString* path = [CCFileUtils fullPathFromRelativePath:img];
#endif
			texture = [[CCTextureCache sharedTextureCache] addImage:path];
           
			if( texture ) {
                #ifndef LH_ARC_ENABLED
                    [texture retain];
                #endif
                
                #if COCOS2D_VERSION >= 0x00020000
                self.shaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_PositionTextureColor]; 
                #endif
                
				imageSize = texture.contentSize;
			}
		}
		
		//CGPoint convert = [[LHSettings sharedInstance] convertRatio];
		winSize = [[CCDirector sharedDirector] winSize];		
		
		
		color       = [textureDict rectForKey:@"Color"];
		lineColor   = [textureDict rectForKey:@"LineColor"];
		lineWidth   = [textureDict floatForKey:@"LineWidth"];
    
        NSDictionary* physicsDict = [dictionary objectForKey:@"PhysicsProperties"];
		[self initTileVerticesFromDictionary:textureDict tileVertices:[physicsDict objectForKey:@"TileVertices"]];
		[self initPathPointsFromDictionary:textureDict];	
		
#ifdef LH_USE_BOX2D
        b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
        if(NULL != world)
            [self createBodyFromDictionary:physicsDict physicWorld:world];
#endif
        
        touchBeginObserver = nil;
        touchMovedObserver = nil;
        touchEndedObserver = nil;
        
        tagTouchBeginObserver = nil;
        tagTouchMovedObserver = nil;
        tagTouchEndedObserver = nil;
        
         [self loadUserCustomInfoFromDictionary:[dictionary objectForKey:@"CustomClassInfo"]];
        
        [LevelHelperLoader setTouchDispatcherForObject:self tag:(int)self.tag];
	}
	return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) bezierWithDictionary:(NSDictionary*)properties
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initWithDictionary:properties] autorelease];
#else
    return [[self alloc] initWithDictionary:properties];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)uniqueName{
    return uniqueName;
}
////////////////////////////////////////////////////////////////////////////////
#ifdef LH_USE_BOX2D
-(b2Body*)body{
    return body;
}
#endif
////////////////////////////////////////////////////////////////////////////////
-(void)visit
{
	[super visit];
}
////////////////////////////////////////////////////////////////////////////////
#if COCOS2D_VERSION >= 0x00020000
-(void)draw{ //COCOS2D 2.0 draw call with GLES 2.0
            
    [super draw];
    
    if(!isVisible)
    {
        return;
    }
//            CC_NODE_DRAW_SETUP();
        
    ccGLEnable( glServerState_ );																\
    NSAssert1(shaderProgram_, @"No shader program set for node: %@", self);                      \
    [shaderProgram_ use];
    
    #if COCOS2D_VERSION >= 0x00020100
        [shaderProgram_ setUniformsForBuiltins];
    #else
        [shaderProgram_ setUniformForModelViewProjectionMatrix];
    #endif
    
    int size = (int)[trianglesHolder count];
    
    lhV3F_C4B_T2F_Triangle points[size];// = new ccV3F_C4B_T2F_Triangle[size];
    
    ccColor4B colorVert = { (GLubyte)(color.origin.x*255.0f), 
                            (GLubyte)(color.origin.y*255.0f), 
                            (GLubyte)(color.size.width*255.0f), 
                            (GLubyte)(opacity*255.0f)};
    
    for(int k = 0; k < (int)[trianglesHolder count]; ++k)
    {
        NSArray* fix = [trianglesHolder objectAtIndex:(NSUInteger)k];
        
        for(int j = 0; j < 3; ++j)
        {
            NSValue* val  = [fix objectAtIndex:(NSUInteger)j];
            
            CGPoint pt = LHPointFromValue(val);
            
            ccVertex3F vert = {pt.x, pt.y, 0};
            ccTex2F tex = { (pt.x/imageSize.width), 
                ((winSize.height - pt.y)/imageSize.height)};
            
            if(j == 0)
            {
                points[k].tl.vertices = vert;
                points[k].tl.colors = colorVert;
                points[k].tl.texCoords = tex;                
            }
            else if(j == 1)
            {
                points[k].tr.vertices = vert;
                points[k].tr.colors = colorVert;
                points[k].tr.texCoords = tex;                                    
            }
            else if (j == 2)
            {
                points[k].bc.vertices = vert;
                points[k].bc.colors = colorVert;
                points[k].bc.texCoords = tex;                
            }
        }
    }
    
    
    ccBlendFunc	blendFunc_;				// Needed for the texture protocol
    
    blendFunc_.src = GL_SRC_ALPHA;
    blendFunc_.dst = GL_ONE_MINUS_SRC_ALPHA;
    
    
    ccGLEnableVertexAttribs( kCCVertexAttribFlag_PosColorTex );
    
    ccGLBlendFunc( blendFunc_.src, blendFunc_.dst );
    
    if(texture)
    {
        ccGLBindTexture2D( texture.name );
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    }
    
#define kPointSize sizeof(ccV3F_C4B_T2F)
    long offset = (long)&points;
    
    // vertex
    NSInteger diff = offsetof( ccV3F_C4B_T2F, vertices);
    glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kPointSize, (void*) (offset + diff));
    
    // texCoods
    diff = offsetof( ccV3F_C4B_T2F, texCoords);
    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kPointSize, (void*)(offset + diff));
    
    // color
    diff = offsetof( ccV3F_C4B_T2F, colors);
    glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kPointSize, (void*)(offset + diff));
    
    glDrawArrays(GL_TRIANGLES, 0, 3*size);
    
    
    bool wasBlend = glIsEnabled(GL_BLEND);
    glEnable(GL_BLEND);            
    
    for(LHBezierBlendingInfo* info in blendingTextures)
    {
        CCTexture2D* tex = [info texture];
        if(NULL != tex)
        {
            glBlendFunc([info blendSource], [info blendDestination]);
            glBindTexture(GL_TEXTURE_2D, [tex name]);
            
            if([info tile]){
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
            }
            
            glDrawArrays(GL_TRIANGLES, 0, 3*size);
        }
    }
    
    if(!wasBlend)
        glDisable(GL_BLEND);
    
    if(drawBorder)
    {
    float oldLineWidth = 1.0f;
    glGetFloatv(GL_LINE_WIDTH, &oldLineWidth); 
    
#ifdef __CC_PLATFORM_IOS
    glLineWidth(lineWidth*[[CCDirector sharedDirector] contentScaleFactor]);
#else
    glLineWidth(lineWidth);
#endif
    
    ccColor4F colorLineVert = { (lineColor.origin.x),
                                (lineColor.origin.y),
                                (lineColor.size.width),
                                (opacity)};
    
    
    int linesNo = (int)[linesHolder count];
    
    [mShaderProgram use];
        
#if COCOS2D_VERSION >= 0x00020100
        [shaderProgram_ setUniformsForBuiltins];
#else
        [shaderProgram_ setUniformForModelViewProjectionMatrix];
#endif
	[mShaderProgram setUniformLocation:(NSUInteger)mColorLocation withF1:colorLineVert.r f2:colorLineVert.g f3:colorLineVert.b f4:colorLineVert.a];
    
    
    CGPoint* line_verts = new CGPoint[[linesHolder count]];
    for(int i = 0; i < (int)[linesHolder count]; i+=2)
    {
        CGPoint pt1 = LHPointFromValue([linesHolder objectAtIndex:(NSUInteger)i]);
        CGPoint pt2 = LHPointFromValue([linesHolder objectAtIndex:(NSUInteger)(i+1)]);
        
        line_verts[i] = pt1;
        line_verts[i+1] = pt2;            
    }  
    glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, line_verts);
    
	glDrawArrays(GL_LINES, 0, linesNo);
	
	CC_INCREMENT_GL_DRAWS(1);
    
    delete[] line_verts;
    }
    
	CHECK_GL_ERROR_DEBUG();
}
#else

-(void)draw
{
    if(!isVisible)
        return;
    
    float scale = CC_CONTENT_SCALE_FACTOR();

	if(0.0f != [[LHSettings sharedInstance] customAlpha])
	{
		glColor4f(color.origin.x, 
				  color.origin.y, 
				  color.size.width, 
				  opacity*[[LHSettings sharedInstance] customAlpha]);
		glPushMatrix();
		
        glDisableClientState(GL_COLOR_ARRAY);
        
		glEnable(GL_TEXTURE_2D);		
		glBindTexture(GL_TEXTURE_2D, texture.name);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		        
        int size = (int)[trianglesHolder count];
        CGPoint* glVertices = new CGPoint[size*3];
        CGPoint* glUV = new CGPoint[size*3];
        for(int k = 0; k < (int)[trianglesHolder count]; ++k)
        {
            NSArray* fix = [trianglesHolder objectAtIndex:k];
            
            for(int j = 0; j < 3; ++j)
			{
                NSValue* val  = [fix objectAtIndex:j];
                
				CGPoint pt = LHPointFromValue(val);
                
                pt.x *= scale;
                pt.y *= scale;

                
				glVertices[k*3 +j] =pt;
				
				glUV[k*3+j].x = (pt.x/imageSize.width);
				glUV[k*3+j].y = ((winSize.height - pt.y)/imageSize.height);
			}
        }
        glTexCoordPointer(2, GL_FLOAT, 0, glUV);
        glVertexPointer(2, GL_FLOAT, 0, glVertices);
        glDrawArrays(GL_TRIANGLES, 0, 3*size);
        
        
        bool wasBlend = glIsEnabled(GL_BLEND);
        glEnable(GL_BLEND);            
        int oldBlendDST = 0;
        glGetIntegerv(GL_BLEND_DST, &oldBlendDST);
        int oldBlendSRC = 0;
        glGetIntegerv(GL_BLEND_SRC, &oldBlendSRC);
        
        for(LHBezierBlendingInfo* info in blendingTextures)
        {
            CCTexture2D* tex = [info texture];
            if(NULL != tex)
            {
                glBlendFunc([info blendSource], [info blendDestination]);
                glBindTexture(GL_TEXTURE_2D, [tex name]);
                
                if([info tile]){
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
                }
                
                glTexCoordPointer(2, GL_FLOAT, 0, glUV);
                glVertexPointer(2, GL_FLOAT, 0, glVertices);
                glDrawArrays(GL_TRIANGLES, 0, 3*size);                
            }
        }
        
        glBlendFunc(oldBlendSRC, oldBlendDST);
        if(!wasBlend)
            glDisable(GL_BLEND);
        
        
        delete[] glVertices;
        delete[] glUV;
        
        if(drawBorder)
        {
            float oldLineWidth = 1.0f;
            glGetFloatv(GL_LINE_WIDTH, &oldLineWidth); 
            

    #ifdef __CC_PLATFORM_IOS
            glLineWidth(lineWidth*[[CCDirector sharedDirector] contentScaleFactor]);
    #else
            glLineWidth(lineWidth);
    #endif
            
            glDisable(GL_TEXTURE_2D);
            glDisableClientState(GL_TEXTURE_COORD_ARRAY);
            glColor4f(lineColor.origin.x, 
                      lineColor.origin.y, 
                      lineColor.size.width, 
                      opacity*[[LHSettings sharedInstance] customAlpha]);
            
            CGPoint* line_verts = new CGPoint[[linesHolder count]];
            for(int i = 0; i < (int)[linesHolder count]; i+=2)
            {
                CGPoint pt1 = LHPointFromValue([linesHolder objectAtIndex:i]);
                CGPoint pt2 = LHPointFromValue([linesHolder objectAtIndex:i+1]);
                
                pt1.x *= scale;
                pt1.y *= scale;
                
                pt2.x *= scale;
                pt2.y *= scale;
                
                line_verts[i] = pt1;
                line_verts[i+1] = pt2;            
            }
            glVertexPointer(2, GL_FLOAT, 0, line_verts);
            glDrawArrays(GL_LINES, 0, (int)[linesHolder count]);
            delete[] line_verts;
            
            glEnableClientState(GL_TEXTURE_COORD_ARRAY);
            glEnableClientState(GL_COLOR_ARRAY);
            glLineWidth(oldLineWidth);
        }
        glEnable(GL_TEXTURE_2D);
        glPopMatrix();
        
        
	}
}
#endif
////////////////////////////////////////////////////////////////////////////////
-(void) pushBlendingTextureNamed:(NSString*) texName
                      shouldTile:(bool)tile
                  blendingSource:(GLenum)blendSource
             blendingDestination:(GLenum)blendDestination{
    
    
    if(!isTile)
        return;
    
    CCTexture2D* tex = [[CCTextureCache sharedTextureCache] addImage:texName];
    if(NULL != tex){
        LHBezierBlendingInfo* info = [LHBezierBlendingInfo bezierBlendingInfoWithTexture:tex 
                                                                             blendSource:blendSource 
                                                                        blendDestination:blendDestination
                                                                                    tile:tile];
        [blendingTextures addObject:info];
    }
}
//------------------------------------------------------------------------------
-(void) pushBlendingTextureNamed:(NSString*) texName
                      shouldTile:(bool)tile{

    [self pushBlendingTextureNamed:texName
                        shouldTile:tile
                    blendingSource:GL_DST_COLOR
               blendingDestination:GL_ZERO];
}
//------------------------------------------------------------------------------
-(void) pushBlendingTextureNamed:(NSString*) texName{    
    [self pushBlendingTextureNamed:texName
                        shouldTile:YES
                    blendingSource:GL_DST_COLOR
               blendingDestination:GL_ZERO];
}
////////////////////////////////////////////////////////////////////////////////
+(bool) isLHBezier:(id)object{
    if([object isKindOfClass:[LHBezier class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{
    
#ifdef LH_USE_BOX2D
    if(body != NULL)
    {
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], 
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
#endif
    return false;
}
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    [self registerTouchBeganObserver:observer selector:selector];
}

-(void)registerTouchBeganObserver:(id)observer selector:(SEL)selector{
    
    if(!isTile){
        NSLog(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }

    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
    
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
    
    [LevelHelperLoader setTouchDispatcherForObject:self tag:(int)self.tag];
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(!isTile){
        NSLog(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }

    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];    
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{

    if(!isTile){
        NSLog(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }
    
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector; 
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above 
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif    
}
#endif
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
    CGPoint touchPoint = [touch locationInView:[touch view]];    
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];    

    
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.bezier = self;
        info.delta = CGPointZero;

        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 

        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];
    
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];    
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);
    info.bezier = self;
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info];     
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];

    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];    

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.bezier = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info];         
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{   
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
            
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
#endif //touch events on mac
//------------------------------------------------------------------------------

#ifdef LH_USE_BOX2D
+(NSString*) uniqueNameForBody:(b2Body*)body{
    
#ifndef LH_ARC_ENABLED
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return [spr uniqueName];
    
    if([LHBezier isLHBezier:spr])
        return [spr uniqueName];
    
    return nil;
}
//------------------------------------------------------------------------------
+(LHBezier*) bezierForBody:(b2Body*)body
{
    if(0 == body)
        return nil;
#ifndef LH_ARC_ENABLED
    id bz = (id)body->GetUserData();
#else
    id bz = (__bridge id)body->GetUserData();
#endif
    
    if([LHBezier isLHBezier:bz])
        return bz;
    
    return nil;
}
//------------------------------------------------------------------------------
+(int) tagForBody:(b2Body*)body{
    if(0 != body){
#ifndef LH_ARC_ENABLED
        CCNode* spr = (CCNode*)body->GetUserData();
#else
        CCNode* spr = (__bridge CCNode*)body->GetUserData();
#endif
        if(nil != spr){
            return (int)[spr tag];
        }
    }
    return -1;
}

-(void)setCollisionFilterCategory:(int)category{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = (uint16)category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterMask:(int)mask{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = (uint16)mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterGroup:(int)group{
    if(body == nil)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = (int16)group;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}

#endif
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
-(id)userInfo{
    return userCustomInfo;
}
@end
